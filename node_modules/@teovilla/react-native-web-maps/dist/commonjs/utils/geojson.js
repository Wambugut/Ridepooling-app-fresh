"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.makePoint = exports.makeOverlays = exports.makeOverlay = exports.makeLine = exports.makeCoordinates = exports.getStrokeWidth = exports.getRgbaFromHex = exports.getColor = exports.flatten = exports.doesOverlayContainProperty = void 0;
/**
 * This file is taken from `react-native-maps`
 * I guess this has been tested by the creators lol
 * Tried to type it but it's a pain
 * TODO: Type this bs
 * https://github.com/react-native-maps/react-native-maps/blob/master/src/Geojson.js
 */

const makeOverlays = features => {
  const points = features.filter(f => f.geometry && (f.geometry.type === 'Point' || f.geometry.type === 'MultiPoint')).map(feature => makeCoordinates(feature).map(coordinates => makeOverlay(coordinates, feature))).reduce(flatten, []).map(overlay => ({
    ...overlay,
    type: 'point'
  }));
  const lines = features.filter(f => f.geometry && (f.geometry.type === 'LineString' || f.geometry.type === 'MultiLineString')).map(feature => makeCoordinates(feature).map(coordinates => makeOverlay(coordinates, feature))).reduce(flatten, []).map(overlay => ({
    ...overlay,
    type: 'polyline'
  }));
  const multipolygons = features.filter(f => f.geometry && f.geometry.type === 'MultiPolygon').map(feature => makeCoordinates(feature).map(coordinates => makeOverlay(coordinates, feature))).reduce(flatten, []);
  const polygons = features.filter(f => f.geometry && f.geometry.type === 'Polygon').map(feature => makeOverlay(makeCoordinates(feature), feature)).reduce(flatten, []).concat(multipolygons).map(overlay => ({
    ...overlay,
    type: 'polygon'
  }));
  return points.concat(lines).concat(polygons);
};
exports.makeOverlays = makeOverlays;
const flatten = (prev, curr) => prev.concat(curr);
exports.flatten = flatten;
const makeOverlay = (coordinates, feature) => {
  let overlay = {
    feature
  };
  if (feature.geometry.type === 'Polygon' || feature.geometry.type === 'MultiPolygon') {
    overlay.coordinates = coordinates[0];
    if (coordinates.length > 1) {
      overlay.holes = coordinates.slice(1);
    }
  } else {
    overlay.coordinates = coordinates;
  }
  return overlay;
};
exports.makeOverlay = makeOverlay;
const makePoint = c => ({
  latitude: c[1],
  longitude: c[0]
});
exports.makePoint = makePoint;
const makeLine = l => l.map(makePoint);
exports.makeLine = makeLine;
const makeCoordinates = feature => {
  const g = feature.geometry;
  if (g.type === 'Point') {
    return [makePoint(g.coordinates)];
  } else if (g.type === 'MultiPoint') {
    return g.coordinates.map(makePoint);
  } else if (g.type === 'LineString') {
    return [makeLine(g.coordinates)];
  } else if (g.type === 'MultiLineString') {
    return g.coordinates.map(makeLine);
  } else if (g.type === 'Polygon') {
    return g.coordinates.map(makeLine);
  } else if (g.type === 'MultiPolygon') {
    return g.coordinates.map(p => p.map(makeLine));
  } else {
    return [];
  }
};
exports.makeCoordinates = makeCoordinates;
const doesOverlayContainProperty = (overlay, property) => {
  // Geojson may have 0 for the opacity when intention is to not specify the
  // opacity. Therefore, we evaluate the truthiness of the propery where 0
  // would return false.
  return overlay.feature && overlay.feature.properties && overlay.feature.properties[property];
};
exports.doesOverlayContainProperty = doesOverlayContainProperty;
const getRgbaFromHex = function (hex) {
  var _hex$match;
  let alpha = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
  const [r, g, b] = ((_hex$match = hex.match(/\w\w/g)) === null || _hex$match === void 0 ? void 0 : _hex$match.map(x => parseInt(x, 16))) || [0, 0, 0];
  return `rgba(${r},${g},${b},${alpha})`;
};
exports.getRgbaFromHex = getRgbaFromHex;
const getColor = (props, overlay, colorType, overrideColorProp) => {
  if (props.hasOwnProperty(overrideColorProp)) {
    return props[overrideColorProp];
  }
  if (doesOverlayContainProperty(overlay, colorType)) {
    let color = overlay.feature.properties[colorType];
    const opacityProperty = colorType + '-opacity';
    if (doesOverlayContainProperty(overlay, opacityProperty) && color[0] === '#') {
      color = getRgbaFromHex(color, overlay.feature.properties[opacityProperty]);
    }
    return color;
  }
  return;
};
exports.getColor = getColor;
const getStrokeWidth = (props, overlay) => {
  if (props.hasOwnProperty('strokeWidth')) {
    return props.strokeWidth;
  }
  if (doesOverlayContainProperty(overlay, 'stroke-width')) {
    return overlay.feature.properties['stroke-width'];
  }
  return;
};
exports.getStrokeWidth = getStrokeWidth;
//# sourceMappingURL=geojson.js.map