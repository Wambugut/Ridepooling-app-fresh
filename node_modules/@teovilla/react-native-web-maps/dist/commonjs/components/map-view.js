"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MapView = void 0;
var _api = require("@react-google-maps/api");
var _react = _interopRequireWildcard(require("react"));
var _mouseEvent = require("../utils/mouse-event");
var _camera = require("../utils/camera");
var _log = require("../utils/log");
var _useUserLocation = require("../hooks/use-user-location");
var _userLocationMarker = require("./user-location-marker");
var Location = _interopRequireWildcard(require("expo-location"));
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function _MapView(props, ref) {
  // State

  const [map, setMap] = (0, _react.useState)(null);
  const [isGesture, setIsGesture] = (0, _react.useState)(false);
  const userLocation = (0, _useUserLocation.useUserLocation)({
    showUserLocation: props.showsUserLocation || false,
    requestPermission: props.showsUserLocation || !!props.onUserLocationChange || false,
    onUserLocationChange: props.onUserLocationChange,
    followUserLocation: props.followsUserLocation || false
  });
  const {
    isLoaded
  } = (0, _api.useJsApiLoader)({
    googleMapsApiKey: props.googleMapsApiKey || ''
  });

  // Callbacks

  const _onMapReady = (0, _react.useCallback)(_map => {
    var _props$onMapReady;
    setMap(_map);
    (_props$onMapReady = props.onMapReady) === null || _props$onMapReady === void 0 ? void 0 : _props$onMapReady.call(props);
  }, [map, props.onMapReady]);
  const _onDragStart = (0, _react.useCallback)(() => {
    setIsGesture(true);
  }, []);
  const _onRegionChange = (0, _react.useCallback)(() => {
    const bounds = map === null || map === void 0 ? void 0 : map.getBounds();
    if (bounds) {
      var _props$onRegionChange;
      const northEast = bounds.getNorthEast();
      const southWest = bounds.getSouthWest();
      const longitudeDelta = Math.abs(northEast.lng() - southWest.lng());
      const latitudeDelta = Math.abs(northEast.lat() - southWest.lat());
      const center = bounds.getCenter();
      (_props$onRegionChange = props.onRegionChange) === null || _props$onRegionChange === void 0 ? void 0 : _props$onRegionChange.call(props, {
        latitude: center.lat(),
        longitude: center.lng(),
        latitudeDelta,
        longitudeDelta
      }, {
        isGesture
      });
    }
  }, [map, props.onRegionChange, isGesture]);
  const _onRegionChangeComplete = (0, _react.useCallback)(() => {
    const bounds = map === null || map === void 0 ? void 0 : map.getBounds();
    if (bounds) {
      var _props$onRegionChange2;
      const northEast = bounds.getNorthEast();
      const southWest = bounds.getSouthWest();
      const longitudeDelta = Math.abs(northEast.lng() - southWest.lng());
      const latitudeDelta = Math.abs(northEast.lat() - southWest.lat());
      const center = bounds.getCenter();
      (_props$onRegionChange2 = props.onRegionChangeComplete) === null || _props$onRegionChange2 === void 0 ? void 0 : _props$onRegionChange2.call(props, {
        latitude: center.lat(),
        longitude: center.lng(),
        latitudeDelta,
        longitudeDelta
      }, {
        isGesture
      });
    }
    setIsGesture(false);
  }, [map, props.onRegionChange, isGesture]);

  // Ref handle

  (0, _react.useImperativeHandle)(ref, () => ({
    async getCamera() {
      const center = map === null || map === void 0 ? void 0 : map.getCenter();
      return {
        altitude: 0,
        heading: (map === null || map === void 0 ? void 0 : map.getHeading()) || 0,
        pitch: (map === null || map === void 0 ? void 0 : map.getTilt()) || 0,
        // TODO: Review this
        zoom: (map === null || map === void 0 ? void 0 : map.getZoom()) || 0,
        // TODO: Normalize value
        center: {
          latitude: (center === null || center === void 0 ? void 0 : center.lat()) || 0,
          longitude: (center === null || center === void 0 ? void 0 : center.lng()) || 0
        }
      };
    },
    setCamera(camera) {
      map === null || map === void 0 ? void 0 : map.moveCamera((0, _camera.transformRNCameraObject)(camera));
    },
    animateCamera(camera, _opts) {
      map === null || map === void 0 ? void 0 : map.moveCamera((0, _camera.transformRNCameraObject)(camera));
    },
    async getMapBoundaries() {
      const bounds = map === null || map === void 0 ? void 0 : map.getBounds();
      const northEast = bounds === null || bounds === void 0 ? void 0 : bounds.getNorthEast();
      const southWest = bounds === null || bounds === void 0 ? void 0 : bounds.getSouthWest();
      return {
        northEast: {
          latitude: (northEast === null || northEast === void 0 ? void 0 : northEast.lat()) || 0,
          longitude: (northEast === null || northEast === void 0 ? void 0 : northEast.lng()) || 0
        },
        southWest: {
          latitude: (southWest === null || southWest === void 0 ? void 0 : southWest.lat()) || 0,
          longitude: (southWest === null || southWest === void 0 ? void 0 : southWest.lng()) || 0
        }
      };
    },
    animateToRegion(region, _duration) {
      const bounds = new google.maps.LatLngBounds();

      // Source: https://github.com/react-native-maps/react-native-maps/blob/master/android/src/main/java/com/airbnb/android/react/maps/AirMapView.java#L503

      // southWest
      bounds.extend({
        lat: region.latitude - region.latitudeDelta / 2,
        lng: region.longitude - region.longitudeDelta / 2
      });

      // northEast
      bounds.extend({
        lat: region.latitude + region.latitudeDelta / 2,
        lng: region.longitude + region.longitudeDelta / 2
      });

      // panToBounds not working??
      // map?.panToBounds(bounds);
      map === null || map === void 0 ? void 0 : map.fitBounds(bounds);
    },
    fitToCoordinates(coordinates, options) {
      const bounds = new google.maps.LatLngBounds();
      if (coordinates) {
        coordinates === null || coordinates === void 0 ? void 0 : coordinates.forEach(c => bounds.extend({
          lat: c.latitude,
          lng: c.longitude
        }));
      }
      map === null || map === void 0 ? void 0 : map.fitBounds(bounds, options === null || options === void 0 ? void 0 : options.edgePadding);
    },
    setMapBoundaries(northEast, southWest) {
      const bounds = new google.maps.LatLngBounds();
      bounds.extend({
        lat: northEast.latitude,
        lng: northEast.longitude
      });
      bounds.extend({
        lat: southWest.latitude,
        lng: southWest.longitude
      });
      map === null || map === void 0 ? void 0 : map.fitBounds(bounds);
    },
    async pointForCoordinate(coordinate) {
      var _map$getProjection;
      const point = map === null || map === void 0 || (_map$getProjection = map.getProjection()) === null || _map$getProjection === void 0 ? void 0 : _map$getProjection.fromLatLngToPoint({
        lat: coordinate.latitude,
        lng: coordinate.longitude
      });
      return point || {
        x: 0,
        y: 0
      };
    },
    async coordinateForPoint(point) {
      var _map$getProjection2;
      const coord = map === null || map === void 0 || (_map$getProjection2 = map.getProjection()) === null || _map$getProjection2 === void 0 ? void 0 : _map$getProjection2.fromPointToLatLng(new google.maps.Point(point.x, point.y));
      return {
        latitude: (coord === null || coord === void 0 ? void 0 : coord.lat()) || 0,
        longitude: (coord === null || coord === void 0 ? void 0 : coord.lng()) || 0
      };
    },
    async takeSnapshot(_options) {
      (0, _log.logMethodNotImplementedWarning)('takeSnapshot');
      return '';
    },
    async addressForCoordinate(_coordinate) {
      Location.setGoogleApiKey(props.googleMapsApiKey || '');
      const [address] = await Location.reverseGeocodeAsync(_coordinate, {
        useGoogleMaps: true
      });
      return address ? {
        administrativeArea: address.region || '',
        country: address.country || '',
        countryCode: address.isoCountryCode || '',
        locality: address.city || '',
        postalCode: address.postalCode || '',
        name: address.name || '',
        subAdministrativeArea: address.subregion || '',
        subLocality: address.city || '',
        thoroughfare: ''
      } : null;
    },
    animateToNavigation(_location, _bearing, _angle, _duration) {
      (0, _log.logDeprecationWarning)('animateToNavigation');
    },
    animateToCoordinate(_latLng, _duration) {
      (0, _log.logDeprecationWarning)('animateToCoordinate');
    },
    animateToBearing(_bearing, _duration) {
      (0, _log.logDeprecationWarning)('animateToBearing');
    },
    animateToViewingAngle(_angle, _duration) {
      (0, _log.logDeprecationWarning)('animateToViewingAngle');
    },
    fitToElements(_options) {
      (0, _log.logMethodNotImplementedWarning)('fitToElements');
    },
    fitToSuppliedMarkers(_markers, _options) {
      (0, _log.logMethodNotImplementedWarning)('fitToSuppliedMarkers');
    },
    setIndoorActiveLevelIndex(_index) {
      (0, _log.logMethodNotImplementedWarning)('setIndoorActiveLevelIndex');
    }
  }), [map]);

  // Side effects

  (0, _react.useEffect)(() => {
    if (props.followsUserLocation && userLocation) {
      map === null || map === void 0 ? void 0 : map.panTo({
        lat: userLocation.coords.latitude,
        lng: userLocation.coords.longitude
      });
    }
  }, [props.followsUserLocation, userLocation]);
  const mapNode = (0, _react.useMemo)(() => {
    var _props$initialCamera, _props$initialCamera2, _props$initialCamera3, _props$initialCamera4, _props$initialRegion, _props$initialCamera5, _props$initialRegion2;
    return /*#__PURE__*/_react.default.createElement(_api.GoogleMap, {
      onLoad: _onMapReady,
      onBoundsChanged: _onRegionChange,
      onDragStart: _onDragStart,
      onDragEnd: _onRegionChangeComplete,
      mapContainerStyle: {
        flex: 1
      },
      zoom: ((_props$initialCamera = props.initialCamera) === null || _props$initialCamera === void 0 ? void 0 : _props$initialCamera.zoom) || 3,
      heading: (_props$initialCamera2 = props.initialCamera) === null || _props$initialCamera2 === void 0 ? void 0 : _props$initialCamera2.heading,
      tilt: (_props$initialCamera3 = props.initialCamera) === null || _props$initialCamera3 === void 0 ? void 0 : _props$initialCamera3.pitch,
      onDrag: () => {
        var _props$onPanDrag;
        const center = map === null || map === void 0 ? void 0 : map.getCenter();
        (_props$onPanDrag = props.onPanDrag) === null || _props$onPanDrag === void 0 ? void 0 : _props$onPanDrag.call(props, (0, _mouseEvent.mapMouseEventToMapEvent)(null, center && {
          latitude: center.lat(),
          longitude: center.lng()
        }, map, undefined));
      },
      onClick: e => {
        var _props$onPress;
        return (_props$onPress = props.onPress) === null || _props$onPress === void 0 ? void 0 : _props$onPress.call(props, (0, _mouseEvent.mapMouseEventToMapEvent)(e, null, map, 'press'));
      },
      onDblClick: e => {
        var _props$onDoublePress;
        return (_props$onDoublePress = props.onDoublePress) === null || _props$onDoublePress === void 0 ? void 0 : _props$onDoublePress.call(props, (0, _mouseEvent.mapMouseEventToMapEvent)(e, null, map, 'press'));
      },
      center: map ? map.getCenter() : {
        lat: ((_props$initialCamera4 = props.initialCamera) === null || _props$initialCamera4 === void 0 ? void 0 : _props$initialCamera4.center.latitude) || ((_props$initialRegion = props.initialRegion) === null || _props$initialRegion === void 0 ? void 0 : _props$initialRegion.latitude) || 0,
        lng: ((_props$initialCamera5 = props.initialCamera) === null || _props$initialCamera5 === void 0 ? void 0 : _props$initialCamera5.center.longitude) || ((_props$initialRegion2 = props.initialRegion) === null || _props$initialRegion2 === void 0 ? void 0 : _props$initialRegion2.longitude) || 0
      },
      options: {
        scrollwheel: props.zoomEnabled,
        disableDoubleClickZoom: !props.zoomTapEnabled,
        zoomControl: props.zoomControlEnabled,
        rotateControl: props.rotateEnabled,
        minZoom: props.minZoomLevel,
        // TODO: Normalize value
        maxZoom: props.maxZoomLevel,
        // TODO: Normalize value
        scaleControl: props.showsScale,
        styles: props.customMapStyle,
        ...(props.options || {})
      }
    }, props.showsUserLocation && userLocation && /*#__PURE__*/_react.default.createElement(_userLocationMarker.UserLocationMarker, {
      coordinates: userLocation.coords
    }), props.children);
  }, [_onRegionChange, _onMapReady, userLocation, props.initialCamera, props.initialRegion, props.showsUserLocation, props.onPanDrag, props.onPress, props.onDoublePress, props.zoomEnabled, props.zoomTapEnabled, props.zoomControlEnabled, props.rotateEnabled, props.minZoomLevel, props.maxZoomLevel, props.showsScale, props.customMapStyle, props.options]);
  if (props.provider !== 'google') {
    console.warn('[WARNING] `react-native-web-maps` only suppots google for now. Please pass "google" as provider in props');
    return null;
  }
  return isLoaded ? /*#__PURE__*/_react.default.cloneElement(mapNode) : /*#__PURE__*/_react.default.createElement(_react.default.Fragment, null, props.loadingFallback || null);
}
const MapView = /*#__PURE__*/(0, _react.memo)( /*#__PURE__*/(0, _react.forwardRef)(_MapView));
exports.MapView = MapView;
//# sourceMappingURL=map-view.js.map