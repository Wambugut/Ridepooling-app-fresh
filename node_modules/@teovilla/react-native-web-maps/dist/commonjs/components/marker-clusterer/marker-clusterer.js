"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MarkerClusterer = void 0;
var _react = _interopRequireWildcard(require("react"));
var _region = require("../../utils/region");
var _cluster = require("./cluster");
var _supercluster = _interopRequireDefault(require("supercluster"));
var _marker = require("../marker");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function _MarkerClusterer(props) {
  const [supercluster, _setSupercluster] = (0, _react.useState)(new _supercluster.default());
  const markers = (0, _react.useMemo)(() => _react.default.Children.toArray(props.children).filter(child => {
    return child.type === _marker.Marker;
  }) || [], [props.children]);
  const points = (0, _react.useMemo)(() => markers.map(node => ({
    type: 'Feature',
    properties: {
      cluster: false,
      node
    },
    geometry: {
      type: 'Point',
      coordinates: [Number(node.props.coordinate.longitude), Number(node.props.coordinate.latitude)]
    }
  })), [markers]);
  const clusters = (0, _react.useMemo)(() => {
    if (!props.region) return [];
    const bbox = (0, _region.getBoundByRegion)(props.region);
    supercluster.load(points);
    return supercluster.getClusters(bbox, Math.round(Math.log(360 / props.region.longitudeDelta) / Math.LN2));
  }, [props.region, points]);
  return /*#__PURE__*/_react.default.createElement(_react.default.Fragment, null, clusters.map((feature, idx) => {
    var _props$renderCluster;
    const clusterProperties = feature.properties;
    const clusterProps = {
      expansionZoom: supercluster.getClusterExpansionZoom(clusterProperties.cluster_id),
      pointCount: clusterProperties.point_count,
      pointCountAbbreviated: clusterProperties.point_count_abbreviated,
      coordinate: {
        longitude: feature.geometry.coordinates[0],
        latitude: feature.geometry.coordinates[1]
      }
    };
    return /*#__PURE__*/_react.default.createElement(_react.default.Fragment, {
      key: idx.toString()
    }, feature.properties.cluster === true ? ((_props$renderCluster = props.renderCluster) === null || _props$renderCluster === void 0 ? void 0 : _props$renderCluster.call(props, clusterProps)) || /*#__PURE__*/_react.default.createElement(_cluster.Cluster, clusterProps) : feature.properties.node);
  }));
}
const MarkerClusterer = /*#__PURE__*/(0, _react.memo)(_MarkerClusterer);
exports.MarkerClusterer = MarkerClusterer;
//# sourceMappingURL=marker-clusterer.js.map